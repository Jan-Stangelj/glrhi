#version 460 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba16f, binding = 0) uniform image2D u_resoult;

layout (std140, binding = 0) uniform cam {
    mat4 view;
    mat4 projection;
    vec4 camPos;
};

uniform sampler2D u_position;           // World space position
uniform sampler2D u_normalRoughness;    // World space normal

const float radius = 0.5;
const float bias = 0.025;
const int samplesNum = 8;

const vec3 samples[32] = vec3[32](
    vec3(0.374, 0.892, 0.241),
    vec3(0.512, 0.138, 0.765),
    vec3(0.931, 0.314, 0.091),
    vec3(0.101, 0.733, 0.493),
    vec3(0.682, 0.581, 0.210),
    vec3(0.195, 0.909, 0.387),
    vec3(0.803, 0.229, 0.634),
    vec3(0.027, 0.479, 0.893),
    vec3(0.639, 0.340, 0.585),
    vec3(0.144, 0.927, 0.361),
    vec3(0.492, 0.621, 0.738),
    vec3(0.015, 0.406, 0.967),
    vec3(0.701, 0.199, 0.561),
    vec3(0.832, 0.387, 0.109),
    vec3(0.308, 0.725, 0.877),
    vec3(0.918, 0.043, 0.262),
    vec3(0.487, 0.567, 0.133),
    vec3(0.774, 0.303, 0.946),
    vec3(0.056, 0.849, 0.397),
    vec3(0.640, 0.194, 0.761),
    vec3(0.213, 0.481, 0.869),
    vec3(0.987, 0.612, 0.057),
    vec3(0.349, 0.708, 0.292),
    vec3(0.476, 0.150, 0.885),
    vec3(0.229, 0.970, 0.304),
    vec3(0.601, 0.308, 0.776),
    vec3(0.412, 0.839, 0.184),
    vec3(0.156, 0.677, 0.936),
    vec3(0.524, 0.231, 0.495),
    vec3(0.771, 0.680, 0.093),
    vec3(0.342, 0.914, 0.420),
    vec3(0.283, 0.379, 0.998)
);

const vec3 noiseVectors[16] = vec3[16](
    vec3( 0.707,  0.707, 0.0),
    vec3(-0.707,  0.707, 0.0),
    vec3( 0.923,  0.383, 0.0),
    vec3(-0.383,  0.923, 0.0),

    vec3( 0.924, -0.383, 0.0),
    vec3(-0.924, -0.383, 0.0),
    vec3( 0.383, -0.924, 0.0),
    vec3(-0.707, -0.707, 0.0),

    vec3( 1.0,    0.0,   0.0),
    vec3( 0.0,    1.0,   0.0),
    vec3(-1.0,    0.0,   0.0),
    vec3( 0.0,   -1.0,   0.0),

    vec3( 0.195,  0.981, 0.0),
    vec3(-0.831,  0.556, 0.0),
    vec3( 0.608, -0.793, 0.0),
    vec3(-0.383, -0.924, 0.0)
);


void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(u_resoult);
    vec2 texUV = vec2(texelCoord) / vec2(imageSize);

    vec3 inColor = imageLoad(u_resoult, texelCoord).rgb;

    vec3 fragPosWorld = texture(u_position, texUV).rgb;
    vec3 normalWorld = normalize(texture(u_normalRoughness, texUV).rgb);

    // Pick a random vector (based on texelCoord or texUV)
    int index = (texelCoord.x + texelCoord.y * 4) % 16;
    vec3 randVec = noiseVectors[index];

    // Orthonormal basis (tangent & bitangent)
    vec3 tangent = normalize(randVec - normalWorld * dot(randVec, normalWorld));
    vec3 bitangent = cross(normalWorld, tangent);
    mat3 TBN = mat3(tangent, bitangent, normalWorld);


    float occlusion = 0.0;

    // Transform world-space fragPos to view space
    vec3 fragPosView = (view * vec4(fragPosWorld, 1.0)).xyz;

    for (int i = 0; i < samplesNum; ++i) {
        vec3 sampleWorld = fragPosWorld + TBN * samples[i] * radius;

        // Convert sample position to view space
        vec3 sampleView = (view * vec4(sampleWorld, 1.0)).xyz;

        // Project to screen space
        vec4 offset = projection * vec4(sampleView, 1.0);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5; // NDC to UV

        // Skip out of bounds
        if (offset.x < 0.0 || offset.x > 1.0 || offset.y < 0.0 || offset.y > 1.0)
            continue;

        float sampleDepthView = (view * vec4(texture(u_position, offset.xy).rgb, 1.0)).z;

        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPosView.z - sampleDepthView));
        if (sampleDepthView >= sampleView.z + bias)
            occlusion += rangeCheck;
    }

    occlusion = 1.0 - (occlusion / samplesNum);

    imageStore(u_resoult, texelCoord, vec4(inColor * occlusion, 1.0));
}
